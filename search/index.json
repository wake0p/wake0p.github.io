[{"content":"前言 项目地址: Xphone\n自己开发了一个 戒掉短视频和手机游戏的 app , 开发过程中从 shizuku 中学习到了非 root 手机持久化获取 adb 权限的方法 特来记录一番.\nXphone 开发心得 android 内核为 linux 系统, linux 将系统权限划分为 root 和 非root权限,由于厂商不希望用户自定义去修改内核因此默认ban了root权限,但是呢开发者又需要能管理其他app的权限, 于是 android 以 root 权限启动init.rc及其配置的系统服务(包含 adbd) ,然后adbd又被设置为 shell 权限\n1 2 setgid(AID_SHELL); setuid(AID_SHELL); 而这个adb_shell 权限是能够操控其他app的, 因此如果我们能够维持一个 adb_shell 这样的高权限,就能过实现当前 OutPhone 的核心功能 任意隐藏/显示 app.\n那么我们该如何维持高权限呢? 这里就不得不参考一下 shizuku 的代码实现了,下面是 shizuku 代码实现分析.\n在 shizuku 中需要用户认证 adb 调试, 通过无线/有限/root的方式实现权限认证, 这里以无线认证的方式进行一步一步分析源码\n寻找 adb 端口 AdbMdns.kt 用于在当前的局域网中寻找服务和对应的 IP port 寻找过程如下\n通过 discoverServices 函数匹配服务名称 \u0026ldquo;_adb-tls-pairing._tcp\u0026rdquo; 1 nsdManager.discoverServices(serviceType, NsdManager.PROTOCOL_DNS_SD, listener) 这里使用了 callback 的机制, 传入 listener 当找到服务名称之后就去回掉 onServiceFound\n1 2 3 private fun onServiceFound(info: NsdServiceInfo) { nsdManager.resolveService(info, ResolveListener(this)) } 而 onServiceFound 调用 resolveService 方法去获取 IP 和 port , 获取成功后回 onServiceResolved\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private fun onServiceResolved(resolvedService: NsdServiceInfo) { if (running \u0026amp;\u0026amp; NetworkInterface.getNetworkInterfaces() .asSequence() .any { networkInterface -\u0026gt; networkInterface.inetAddresses .asSequence() .any { resolvedService.host.hostAddress == it.hostAddress } } \u0026amp;\u0026amp; isPortAvailable(resolvedService.port) ) { serviceName = resolvedService.serviceName observer.onChanged(resolvedService.port) } } 该函数遍历当前手机的所有网卡 IP 然后和刚刚解析到的地址进行对比, 如果相同则尝试 bind 判断端口是否被占用.\n当ip端口被找到之后,会callback onChanged 函数将找到的 port 传出, 这里的 onChanged 属于 observer 类\n1 2 3 4 5 6 7 8 9 10 private val observer = Observer\u0026lt;Int\u0026gt; { port -\u0026gt; Log.i(tag, \u0026#34;Pairing service port: $port\u0026#34;) if (port \u0026lt;= 0) return@Observer // Since the service could be killed before user finishing input, // we need to put the port into Intent val notification = createInputNotification(port) getSystemService(NotificationManager::class.java).notify(notificationId, notification) } onChanged 函数调用 NotificationManager.notify 创建输入的通知输入对应的匹配码, 而在 notification 对象中指定用户需要启动的 Intent 类为 AdbPairingService (这里创建了一个 PendingIntent 包装 Intent ****)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 private fun createInputNotification(port: Int): Notification { return Notification.Builder(this, notificationChannel) .setColor(getColor(R.color.notification)) .setContentTitle(getString(R.string.notification_adb_pairing_service_found_title)) .setSmallIcon(R.drawable.ic_system_icon) .addAction(replyNotificationAction(port)) .build() } private fun replyNotificationAction(port: Int): Notification.Action { // Ensure pending intent is created val action = replyNotificationAction PendingIntent.getForegroundService( this, replyRequestId, replyIntent(this, port), if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.S) PendingIntent.FLAG_MUTABLE or PendingIntent.FLAG_UPDATE_CURRENT else PendingIntent.FLAG_UPDATE_CURRENT ) return action } private fun replyIntent(context: Context, port: Int): Intent { return Intent(context, AdbPairingService::class.java).setAction(replyAction).putExtra(portKey, port) } 而当前类正在运行当中因此用户输入匹配码并且点击发送之后,就会回到 onStartCommand 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int { val notification = when (intent?.action) { startAction -\u0026gt; { onStart() } replyAction -\u0026gt; { val code = RemoteInput.getResultsFromIntent(intent)?.getCharSequence(remoteInputResultKey) ?: \u0026#34;\u0026#34; val port = intent.getIntExtra(portKey, -1) if (port != -1) { onInput(code.toString(), port) } else { onStart() } } stopAction -\u0026gt; { stopForeground(STOP_FOREGROUND_REMOVE) stopSelf() null } else -\u0026gt; { return START_NOT_STICKY } } if (notification != null) { try { startForeground(notificationId, notification, ServiceInfo.FOREGROUND_SERVICE_TYPE_MANIFEST) } catch (e: Throwable) { Log.e(tag, \u0026#34;startForeground failed\u0026#34;, e) if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.S \u0026amp;\u0026amp; e is ForegroundServiceStartNotAllowedException) { getSystemService(NotificationManager::class.java).notify(notificationId, notification) } } } return START_REDELIVER_INTENT } 并且匹配到 replyAction ,用于提取 port 和 code, 然后再调用 onInput\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 代码位置: AdbPairingService.kt lines 143-164 private fun onInput(code: String, port: Int): Notification { GlobalScope.launch(Dispatchers.IO) { val host = \u0026#34;127.0.0.1\u0026#34; // 1. 获取/生成 ADB 密钥 val key = try { // AdbKey 的构造函数会尝试读取现有密钥或生成新密钥 AdbKey(PreferenceAdbKeyStore(ShizukuSettings.getPreferences()), \u0026#34;shizuku\u0026#34;) } catch (e: Throwable) { e.printStackTrace() return@launch } // 2. 发起配对连接 // 使用 AdbPairingClient 进行 TLS 配对 AdbPairingClient(host, port, code, key).runCatching { start() }.onFailure { handleResult(false, it) }.onSuccess { handleResult(it, null) } } return workingNotification } 和 adb 服务器进行认证 onInput 调用 AdbKey , 他和 adb 建立连接 并且生成rsa密钥,并且保存到本地的adb 服务上\n在 AdbKey 的 初始化函数中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 init { this.encryptionKey = getOrCreateEncryptionKey() ?: error(\u0026#34;Failed to generate encryption key with AndroidKeyManager.\u0026#34;) this.privateKey = getOrCreatePrivateKey() this.publicKey = KeyFactory.getInstance(\u0026#34;RSA\u0026#34;).generatePublic(RSAPublicKeySpec(privateKey.modulus, RSAKeyGenParameterSpec.F4)) as RSAPublicKey val signer = JcaContentSignerBuilder(\u0026#34;SHA256withRSA\u0026#34;).build(privateKey) val x509Certificate = X509v3CertificateBuilder(X500Name(\u0026#34;CN=00\u0026#34;), BigInteger.ONE, Date(0), Date(2461449600 * 1000), Locale.ROOT, X500Name(\u0026#34;CN=00\u0026#34;), SubjectPublicKeyInfo.getInstance(publicKey.encoded) ).build(signer) this.certificate = CertificateFactory.getInstance(\u0026#34;X.509\u0026#34;) .generateCertificate(ByteArrayInputStream(x509Certificate.encoded)) as X509Certificate Log.d(TAG, privateKey.toString()) } val adbPublicKey: ByteArray by unsafeLazy { publicKey.adbEncoded(name) } 该函数大概做了四件事情\n获取加密密钥 (Encryption Key): Android Keystore 系统 (ANDROID_KEYSTORE) 获取或生成一个 AES-256 (GCM模式) 的密钥 获取/生成 RSA 私钥 (Private Key): 从 ShizukuSettings.SharedPreferences 中读取密钥,如果为空则重新生成 RSA 密钥,并且通过 AES 加密密钥并存储到 SharedPreferences 中 生成 x509Certificate 证书 通过 by unsafeLazy 懒加载模式 生成 publicKey 这个 key 用于 后续服务器 adb 认证 利用刚刚生成的 key 和adb服务器进行通信 调用 AdbPairingClient 的 start 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 fun start(): Boolean { // 1. 建立基础的 TLS 连接 // 这是一个同步阻塞调用，会建立 TCP 连接并完成 TLS 握手，同时通过 Conscrypt 导出关键的密钥材料 setupTlsConnection() // 2. 更新状态：开始交换 SPAKE2 协议消息 state = State.ExchangingMsgs // 3. 执行核心的密钥交换协议 (SPAKE2 msg exchange) // 这个函数会通过网络发送和接收数据包，验证双方是否拥有相同的\u0026#34;密码\u0026#34;（即配对码） // 如果失败返回 false，配对终止 if (!doExchangeMsgs()) { state = State.Stopped return false } // 4. 更新状态：交换设备信息 // 密码验证成功后，双方交换具体的设备标识和对端公钥 (Peer Info) state = State.ExchangingPeerInfo // 5. 执行信息交换 // 这里会将我们自己的 RSA 公钥发送给手机，告诉它“请信任这台电脑/APP” if (!doExchangePeerInfo()) { state = State.Stopped return false } // 6. 配对成功完成 state = State.Stopped return true } private fun setupTlsConnection() { // 1. 创建普通 TCP Socket // host = \u0026#34;127.0.0.1\u0026#34; (通常通过端口转发或直接连), port 由 mDNS 发现 socket = Socket(host, port) // 2. 禁用 Nagle 算法 // 确保数据包立即发送，对这种交互式握手协议很重要，避免延迟 socket.tcpNoDelay = true // 3. 升级为 TLS (SSL) Socket // key.sslContext 是之前配置好的，包含自签名证书作为客户端证书 // 注意：这里的 TLS 握手并不验证服务器证书（因为是匿名/自签名），安全性依赖后续的配对码验证 val sslContext = key.sslContext val sslSocket = sslContext.socketFactory.createSocket(socket, host, port, true) as SSLSocket // 4. 开始 TLS 握手 // 阻塞直到握手完成。此时建立了加密通道，但双方还没验证身份（因为都是自签名） sslSocket.startHandshake() Log.d(TAG, \u0026#34;Handshake succeeded.\u0026#34;) // 5. 获取输入输出流 // 后续的所有通信都在这个 TLS 隧道内进行 inputStream = DataInputStream(sslSocket.inputStream) outputStream = DataOutputStream(sslSocket.outputStream) // --- 核心安全逻辑开始：生成 SPAKE2 共享密码 --- // 6. 将用户输入的配对码转换为字节 (e.g., \u0026#34;123456\u0026#34; -\u0026gt; bytes) val pairCodeBytes = pairCode.toByteArray() // 7. 导出 TLS 密钥材料 (RFC 5705 Keying Material Exporters) // 这是关键! 只有 Conscrypt (BoringSSL/OpenSSL) 支持。 // 它从 TLS 握手的 master secret 中派生出一段新的密钥数据。 // 这保证了只有刚才参与了这次特定 TLS 握手的双方才能得到个这数据。 val keyMaterial = Conscrypt.exportKeyingMaterial(sslSocket, kExportedKeyLabel, null, kExportedKeySize) // 8. 混合密码：拼接 [配对码] + [TLS密钥材料] val passwordBytes = ByteArray(pairCode.length + keyMaterial.size) pairCodeBytes.copyInto(passwordBytes) // 先填配对码 keyMaterial.copyInto(passwordBytes, pairCodeBytes.size) // 再填导出的密钥材料 // 9. 初始化 SPAKE2 配对上下文 (Native 调用) // 使用这个混合后的 \u0026#34;passwordBytes\u0026#34; 初始化 SPAKE2 算法。 // 只有当双方都有相同的配对码 AND 相同的 TLS 导出密钥时，后续的 doExchangeMsgs 才会成功。 // 这有效地防止了中间人攻击（MITM），因为中间人即使拦截了配对码，也无法拥有正确的 TLS master secret。 val pairingContext = PairingContext.create(passwordBytes) checkNotNull(pairingContext) { \u0026#34;Unable to create PairingContext.\u0026#34; } this.pairingContext = pairingContext } 在 AdbPairingClient 的 start 函数中就完成了和 adb 服务器的信息认证,之后通过 AdbClient 与服务器建立连接之后, 通知栏显示配对完成\n启动后台服务 后续启动 shizuku 后 进入主界面点击无线模式的启动之后,会调用 onCreate ,该函数会 初始化 viewModel\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 private class ViewModel(context: Context, root: Boolean, host: String?, port: Int) : androidx.lifecycle.ViewModel() { private val sb = StringBuilder() private val _output = MutableLiveData\u0026lt;Resource\u0026lt;StringBuilder\u0026gt;\u0026gt;() val output = _output as LiveData\u0026lt;Resource\u0026lt;StringBuilder\u0026gt;\u0026gt; init { try { if (root) { startRoot() } else { startAdb(host!!, port) } } catch (e: Throwable) { postResult(e) } } } 而在 viewModel 中调用 startAdb 进行持久化权限维持\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 private fun startAdb(host: String, port: Int) { sb.append(\u0026#34;Starting with wireless adb in port $port...\u0026#34;).append(\u0026#39;\\n\u0026#39;).append(\u0026#39;\\n\u0026#39;) postResult() GlobalScope.launch(Dispatchers.IO) { val key = try { AdbKey(PreferenceAdbKeyStore(ShizukuSettings.getPreferences()), \u0026#34;shizuku\u0026#34;) } catch (e: Throwable) { e.printStackTrace() sb.append(\u0026#39;\\n\u0026#39;).append(Log.getStackTraceString(e)) postResult(AdbKeyException(e)) return@launch } AdbClient(host, port, key).runCatching { connect() shellCommand(Starter.internalCommand) { sb.append(String(it)) postResult() } close() }.onFailure { it.printStackTrace() sb.append(\u0026#39;\\n\u0026#39;).append(Log.getStackTraceString(it)) postResult(it) } } } // 对应的 internalCommand object Starter { private val starterFile = File(application.applicationInfo.nativeLibraryDir, \u0026#34;libshizuku.so\u0026#34;) val userCommand: String = starterFile.absolutePath val adbCommand = \u0026#34;adb shell $userCommand\u0026#34; val internalCommand = \u0026#34;$userCommand --apk=${application.applicationInfo.sourceDir}\u0026#34; } 持久化的方式就是 让 adb shell 去执行 libshizuku.so —apk=”base.apk” 而 libshizuku.so 的代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;dirent.h\u0026gt; #include \u0026lt;ctime\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;libgen.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;sys/system_properties.h\u0026gt; #include \u0026lt;cerrno\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;termios.h\u0026gt; #include \u0026#34;android.h\u0026#34; #include \u0026#34;misc.h\u0026#34; #include \u0026#34;selinux.h\u0026#34; #include \u0026#34;cgroup.h\u0026#34; #include \u0026#34;logging.h\u0026#34; #ifdef DEBUG #define JAVA_DEBUGGABLE #endif #define perrorf(...) fprintf(stderr, __VA_ARGS__) #define EXIT_FATAL_SET_CLASSPATH 3 #define EXIT_FATAL_FORK 4 #define EXIT_FATAL_APP_PROCESS 5 #define EXIT_FATAL_UID 6 #define EXIT_FATAL_PM_PATH 7 #define EXIT_FATAL_KILL 9 #define EXIT_FATAL_BINDER_BLOCKED_BY_SELINUX 10 #define PACKAGE_NAME \u0026#34;moe.shizuku.privileged.api\u0026#34; #define SERVER_NAME \u0026#34;shizuku_server\u0026#34; #define SERVER_CLASS_PATH \u0026#34;rikka.shizuku.server.ShizukuService\u0026#34; #if defined(__arm__) #define ABI \u0026#34;arm\u0026#34; #elif defined(__i386__) #define ABI \u0026#34;x86\u0026#34; #elif defined(__x86_64__) #define ABI \u0026#34;x86_64\u0026#34; #elif defined(__aarch64__) #define ABI \u0026#34;arm64\u0026#34; #endif static void run_server(const char *dex_path, const char *main_class, const char *process_name) { if (setenv(\u0026#34;CLASSPATH\u0026#34;, dex_path, true)) { LOGE(\u0026#34;can\u0026#39;t set CLASSPATH\\n\u0026#34;); exit(EXIT_FATAL_SET_CLASSPATH); } #define ARG(v) char **v = nullptr; \\ char buf_##v[PATH_MAX]; \\ size_t v_size = 0; \\ uintptr_t v_current = 0; #define ARG_PUSH(v, arg) v_size += sizeof(char *); \\ if (v == nullptr) { \\ v = (char **) malloc(v_size); \\ } else { \\ v = (char **) realloc(v, v_size);\\ } \\ v_current = (uintptr_t) v + v_size - sizeof(char *); \\ *((char **) v_current) = arg ? strdup(arg) : nullptr; #define ARG_END(v) ARG_PUSH(v, nullptr) #define ARG_PUSH_FMT(v, fmt, ...) snprintf(buf_##v, PATH_MAX, fmt, __VA_ARGS__); \\ ARG_PUSH(v, buf_##v) #ifdef JAVA_DEBUGGABLE #define ARG_PUSH_DEBUG_ONLY(v, arg) ARG_PUSH(v, arg) #define ARG_PUSH_DEBUG_VM_PARAMS(v) \\ if (android_get_device_api_level() \u0026gt;= 30) { \\ ARG_PUSH(v, \u0026#34;-Xcompiler-option\u0026#34;); \\ ARG_PUSH(v, \u0026#34;--debuggable\u0026#34;); \\ ARG_PUSH(v, \u0026#34;-XjdwpProvider:adbconnection\u0026#34;); \\ ARG_PUSH(v, \u0026#34;-XjdwpOptions:suspend=n,server=y\u0026#34;); \\ } else if (android_get_device_api_level() \u0026gt;= 28) { \\ ARG_PUSH(v, \u0026#34;-Xcompiler-option\u0026#34;); \\ ARG_PUSH(v, \u0026#34;--debuggable\u0026#34;); \\ ARG_PUSH(v, \u0026#34;-XjdwpProvider:internal\u0026#34;); \\ ARG_PUSH(v, \u0026#34;-XjdwpOptions:transport=dt_android_adb,suspend=n,server=y\u0026#34;); \\ } else { \\ ARG_PUSH(v, \u0026#34;-Xcompiler-option\u0026#34;); \\ ARG_PUSH(v, \u0026#34;--debuggable\u0026#34;); \\ ARG_PUSH(v, \u0026#34;-agentlib:jdwp=transport=dt_android_adb,suspend=n,server=y\u0026#34;); \\ } #else #define ARG_PUSH_DEBUG_VM_PARAMS(v) #define ARG_PUSH_DEBUG_ONLY(v, arg) #endif char lib_path[PATH_MAX]{0}; snprintf(lib_path, PATH_MAX, \u0026#34;%s/lib/%s\u0026#34;, dirname(dex_path), ABI); ARG(argv) ARG_PUSH(argv, \u0026#34;/system/bin/app_process\u0026#34;) ARG_PUSH_FMT(argv, \u0026#34;-Djava.class.path=%s\u0026#34;, dex_path) ARG_PUSH_FMT(argv, \u0026#34;-Dshizuku.library.path=%s\u0026#34;, lib_path) ARG_PUSH_DEBUG_VM_PARAMS(argv) ARG_PUSH(argv, \u0026#34;/system/bin\u0026#34;) ARG_PUSH_FMT(argv, \u0026#34;--nice-name=%s\u0026#34;, process_name) ARG_PUSH(argv, main_class) ARG_PUSH_DEBUG_ONLY(argv, \u0026#34;--debug\u0026#34;) ARG_END(argv) LOGD(\u0026#34;exec app_process\u0026#34;); if (execvp((const char *) argv[0], argv)) { exit(EXIT_FATAL_APP_PROCESS); } } static void start_server(const char *path, const char *main_class, const char *process_name) { pid_t pid = fork(); switch (pid) { case -1: { perrorf(\u0026#34;fatal: can\u0026#39;t fork\\n\u0026#34;); exit(EXIT_FATAL_FORK); } case 0: { LOGD(\u0026#34;child\u0026#34;); setsid(); chdir(\u0026#34;/\u0026#34;); int fd = open(\u0026#34;/dev/null\u0026#34;, O_RDWR); if (fd != -1) { dup2(fd, STDIN_FILENO); dup2(fd, STDOUT_FILENO); dup2(fd, STDERR_FILENO); if (fd \u0026gt; 2) close(fd); } run_server(path, main_class, process_name); } default: { printf(\u0026#34;info: shizuku_server pid is %d\\n\u0026#34;, pid); printf(\u0026#34;info: shizuku_starter exit with 0\\n\u0026#34;); exit(EXIT_SUCCESS); } } } static int check_selinux(const char *s, const char *t, const char *c, const char *p) { int res = se::selinux_check_access(s, t, c, p, nullptr); #ifndef DEBUG if (res != 0) { #endif printf(\u0026#34;info: selinux_check_access %s %s %s %s: %d\\n\u0026#34;, s, t, c, p, res); fflush(stdout); #ifndef DEBUG } #endif return res; } static int switch_cgroup() { int pid = getpid(); if (cgroup::switch_cgroup(\u0026#34;/acct\u0026#34;, pid)) { printf(\u0026#34;info: switch cgroup succeeded, cgroup in /acct\\n\u0026#34;); return 0; } if (cgroup::switch_cgroup(\u0026#34;/dev/cg2_bpf\u0026#34;, pid)) { printf(\u0026#34;info: switch cgroup succeeded, cgroup in /dev/cg2_bpf\\n\u0026#34;); return 0; } if (cgroup::switch_cgroup(\u0026#34;/sys/fs/cgroup\u0026#34;, pid)) { printf(\u0026#34;info: switch cgroup succeeded, cgroup in /sys/fs/cgroup\\n\u0026#34;); return 0; } char buf[PROP_VALUE_MAX + 1]; if (__system_property_get(\u0026#34;ro.config.per_app_memcg\u0026#34;, buf) \u0026gt; 0 \u0026amp;\u0026amp; strncmp(buf, \u0026#34;false\u0026#34;, 5) != 0) { if (cgroup::switch_cgroup(\u0026#34;/dev/memcg/apps\u0026#34;, pid)) { printf(\u0026#34;info: switch cgroup succeeded, cgroup in /dev/memcg/apps\\n\u0026#34;); return 0; } } printf(\u0026#34;warn: can\u0026#39;t switch cgroup\\n\u0026#34;); fflush(stdout); return -1; } int main(int argc, char *argv[]) { std::string apk_path; for (int i = 0; i \u0026lt; argc; ++i) { if (strncmp(argv[i], \u0026#34;--apk=\u0026#34;, 6) == 0) { apk_path = argv[i] + 6; } } uid_t uid = getuid(); if (uid != 0 \u0026amp;\u0026amp; uid != 2000) { perrorf(\u0026#34;fatal: run Shizuku from non root nor adb user (uid=%d).\\n\u0026#34;, uid); exit(EXIT_FATAL_UID); } se::init(); if (uid == 0) { switch_cgroup(); if (android_get_device_api_level() \u0026gt;= 29) { printf(\u0026#34;info: switching mount namespace to init...\\n\u0026#34;); switch_mnt_ns(1); } } if (uid == 0) { char *context = nullptr; if (se::getcon(\u0026amp;context) == 0) { int res = 0; res |= check_selinux(\u0026#34;u:r:untrusted_app:s0\u0026#34;, context, \u0026#34;binder\u0026#34;, \u0026#34;call\u0026#34;); res |= check_selinux(\u0026#34;u:r:untrusted_app:s0\u0026#34;, context, \u0026#34;binder\u0026#34;, \u0026#34;transfer\u0026#34;); if (res != 0) { perrorf(\u0026#34;fatal: the su you are using does not allow app (u:r:untrusted_app:s0) to connect to su (%s) with binder.\\n\u0026#34;, context); exit(EXIT_FATAL_BINDER_BLOCKED_BY_SELINUX); } se::freecon(context); } } printf(\u0026#34;info: starter begin\\n\u0026#34;); fflush(stdout); // kill old server printf(\u0026#34;info: killing old process...\\n\u0026#34;); fflush(stdout); foreach_proc([](pid_t pid) { if (pid == getpid()) return; char name[1024]; if (get_proc_name(pid, name, 1024) != 0) return; if (strcmp(SERVER_NAME, name) != 0) return; if (kill(pid, SIGKILL) == 0) printf(\u0026#34;info: killed %d (%s)\\n\u0026#34;, pid, name); else if (errno == EPERM) { perrorf(\u0026#34;fatal: can\u0026#39;t kill %d, please try to stop existing Shizuku from app first.\\n\u0026#34;, pid); exit(EXIT_FATAL_KILL); } else { printf(\u0026#34;warn: failed to kill %d (%s)\\n\u0026#34;, pid, name); } }); if (access(apk_path.c_str(), R_OK) == 0) { printf(\u0026#34;info: use apk path from argv\\n\u0026#34;); fflush(stdout); } if (apk_path.empty()) { auto f = popen(\u0026#34;pm path \u0026#34; PACKAGE_NAME, \u0026#34;r\u0026#34;); if (f) { char line[PATH_MAX]{0}; fgets(line, PATH_MAX, f); trim(line); if (strstr(line, \u0026#34;package:\u0026#34;) == line) { apk_path = line + strlen(\u0026#34;package:\u0026#34;); } pclose(f); } } if (apk_path.empty()) { perrorf(\u0026#34;fatal: can\u0026#39;t get path of manager\\n\u0026#34;); exit(EXIT_FATAL_PM_PATH); } printf(\u0026#34;info: apk path is %s\\n\u0026#34;, apk_path.c_str()); if (access(apk_path.c_str(), R_OK) != 0) { perrorf(\u0026#34;fatal: can\u0026#39;t access manager %s\\n\u0026#34;, apk_path.c_str()); exit(EXIT_FATAL_PM_PATH); } printf(\u0026#34;info: starting server...\\n\u0026#34;); fflush(stdout); LOGD(\u0026#34;start_server\u0026#34;); start_server(apk_path.c_str(), SERVER_CLASS_PATH, SERVER_NAME); } 该代码修改当前进程命名空间和资源空间, 用于避免被系统杀死以及获得全局视角(启动服务器进程和 Init 进程位于同一个命名空间)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 if (uid == 0) { switch_cgroup(); if (android_get_device_api_level() \u0026gt;= 29) { printf(\u0026#34;info: switching mount namespace to init...\\n\u0026#34;); switch_mnt_ns(1); } } static int switch_cgroup() { int pid = getpid(); if (cgroup::switch_cgroup(\u0026#34;/acct\u0026#34;, pid)) { printf(\u0026#34;info: switch cgroup succeeded, cgroup in /acct\\n\u0026#34;); return 0; } if (cgroup::switch_cgroup(\u0026#34;/dev/cg2_bpf\u0026#34;, pid)) { printf(\u0026#34;info: switch cgroup succeeded, cgroup in /dev/cg2_bpf\\n\u0026#34;); return 0; } if (cgroup::switch_cgroup(\u0026#34;/sys/fs/cgroup\u0026#34;, pid)) { printf(\u0026#34;info: switch cgroup succeeded, cgroup in /sys/fs/cgroup\\n\u0026#34;); return 0; } char buf[PROP_VALUE_MAX + 1]; if (__system_property_get(\u0026#34;ro.config.per_app_memcg\u0026#34;, buf) \u0026gt; 0 \u0026amp;\u0026amp; strncmp(buf, \u0026#34;false\u0026#34;, 5) != 0) { if (cgroup::switch_cgroup(\u0026#34;/dev/memcg/apps\u0026#34;, pid)) { printf(\u0026#34;info: switch cgroup succeeded, cgroup in /dev/memcg/apps\\n\u0026#34;); return 0; } } printf(\u0026#34;warn: can\u0026#39;t switch cgroup\\n\u0026#34;); fflush(stdout); return -1; } int switch_mnt_ns(int pid) { char mnt[32]; snprintf(mnt, sizeof(mnt), \u0026#34;/proc/%d/ns/mnt\u0026#34;, pid); if (access(mnt, R_OK) == -1) return -1; int fd = open(mnt, O_RDONLY); if (fd \u0026lt; 0) return -1; int res = setns(fd, 0); close(fd); return res; } 之后就检查 se_linux 规则,是否允许不被信任的 app 进行 binder 通信,如果同意则调用 start_server 启动名为 shizuku_server 的服务器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 static void start_server(const char *path, const char *main_class, const char *process_name) { pid_t pid = fork(); switch (pid) { case -1: { perrorf(\u0026#34;fatal: can\u0026#39;t fork\\n\u0026#34;); exit(EXIT_FATAL_FORK); } case 0: { LOGD(\u0026#34;child\u0026#34;); setsid(); chdir(\u0026#34;/\u0026#34;); int fd = open(\u0026#34;/dev/null\u0026#34;, O_RDWR); if (fd != -1) { dup2(fd, STDIN_FILENO); dup2(fd, STDOUT_FILENO); dup2(fd, STDERR_FILENO); if (fd \u0026gt; 2) close(fd); } run_server(path, main_class, process_name); } default: { printf(\u0026#34;info: shizuku_server pid is %d\\n\u0026#34;, pid); printf(\u0026#34;info: shizuku_starter exit with 0\\n\u0026#34;); exit(EXIT_SUCCESS); } } } 启动方式也很简单\nfork 创建子进程, 让修改 pid 资源目录 文件描述符等让子进程独立开 调用 run_server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 static void run_server(const char *dex_path, const char *main_class, const char *process_name) { if (setenv(\u0026#34;CLASSPATH\u0026#34;, dex_path, true)) { LOGE(\u0026#34;can\u0026#39;t set CLASSPATH\\n\u0026#34;); exit(EXIT_FATAL_SET_CLASSPATH); } #define ARG(v) char **v = nullptr; \\ char buf_##v[PATH_MAX]; \\ size_t v_size = 0; \\ uintptr_t v_current = 0; #define ARG_PUSH(v, arg) v_size += sizeof(char *); \\ if (v == nullptr) { \\ v = (char **) malloc(v_size); \\ } else { \\ v = (char **) realloc(v, v_size);\\ } \\ v_current = (uintptr_t) v + v_size - sizeof(char *); \\ *((char **) v_current) = arg ? strdup(arg) : nullptr; #define ARG_END(v) ARG_PUSH(v, nullptr) #define ARG_PUSH_FMT(v, fmt, ...) snprintf(buf_##v, PATH_MAX, fmt, __VA_ARGS__); \\ ARG_PUSH(v, buf_##v) #ifdef JAVA_DEBUGGABLE #define ARG_PUSH_DEBUG_ONLY(v, arg) ARG_PUSH(v, arg) #define ARG_PUSH_DEBUG_VM_PARAMS(v) \\ if (android_get_device_api_level() \u0026gt;= 30) { \\ ARG_PUSH(v, \u0026#34;-Xcompiler-option\u0026#34;); \\ ARG_PUSH(v, \u0026#34;--debuggable\u0026#34;); \\ ARG_PUSH(v, \u0026#34;-XjdwpProvider:adbconnection\u0026#34;); \\ ARG_PUSH(v, \u0026#34;-XjdwpOptions:suspend=n,server=y\u0026#34;); \\ } else if (android_get_device_api_level() \u0026gt;= 28) { \\ ARG_PUSH(v, \u0026#34;-Xcompiler-option\u0026#34;); \\ ARG_PUSH(v, \u0026#34;--debuggable\u0026#34;); \\ ARG_PUSH(v, \u0026#34;-XjdwpProvider:internal\u0026#34;); \\ ARG_PUSH(v, \u0026#34;-XjdwpOptions:transport=dt_android_adb,suspend=n,server=y\u0026#34;); \\ } else { \\ ARG_PUSH(v, \u0026#34;-Xcompiler-option\u0026#34;); \\ ARG_PUSH(v, \u0026#34;--debuggable\u0026#34;); \\ ARG_PUSH(v, \u0026#34;-agentlib:jdwp=transport=dt_android_adb,suspend=n,server=y\u0026#34;); \\ } #else #define ARG_PUSH_DEBUG_VM_PARAMS(v) #define ARG_PUSH_DEBUG_ONLY(v, arg) #endif char lib_path[PATH_MAX]{0}; snprintf(lib_path, PATH_MAX, \u0026#34;%s/lib/%s\u0026#34;, dirname(dex_path), ABI); ARG(argv) ARG_PUSH(argv, \u0026#34;/system/bin/app_process\u0026#34;) ARG_PUSH_FMT(argv, \u0026#34;-Djava.class.path=%s\u0026#34;, dex_path) ARG_PUSH_FMT(argv, \u0026#34;-Dshizuku.library.path=%s\u0026#34;, lib_path) ARG_PUSH_DEBUG_VM_PARAMS(argv) ARG_PUSH(argv, \u0026#34;/system/bin\u0026#34;) ARG_PUSH_FMT(argv, \u0026#34;--nice-name=%s\u0026#34;, process_name) ARG_PUSH(argv, main_class) ARG_PUSH_DEBUG_ONLY(argv, \u0026#34;--debug\u0026#34;) ARG_END(argv) LOGD(\u0026#34;exec app_process\u0026#34;); if (execvp((const char *) argv[0], argv)) { exit(EXIT_FATAL_APP_PROCESS); } } 这里就是通过 execvp 去执行 app_process 启动 com.safe.discipline.server.ResidentServer JAVA进程. 并且这个 JAVA 拥有shell (pid = 200)进程权限. 最终其实就是在 adb shell 中执行如下指令\n1 2 3 4 5 6 7 8 9 app_process [java-options] cmd-dir start-class-name [options] /system/bin/app_process \\ -Djava.class.path=/data/app/~~.../moe.shizuku.manager.../base.apk \\ -Dshizuku.library.path=/data/app/~~.../moe.shizuku.manager.../lib/arm64 \\ /system/bin \\ --nice-name=shizuku_server \\ moe.shizuku.starter.ServiceStarter \\ --debug # (如果开启了DEBUG) 而 ResidentServer 这里其实就是建立 binder 进行通信(具体内容有空再去分析一下)\n自此 shizuku 就已经成功启动带有adb shell 权限的 Java server , 后续其他 app 需要 adb 操作权限只需要通过 binder 和这个 server 进行通信即可.\nXphone 功能 而我自己开发的这个 app 就是基于 shizuku 实现的 自定义 APP 隐藏目前存在如下功能\n快速选择 APP 进行隐藏 对 APP 进行分类 指定时间和星期自动隐藏/显示APP 存在强制模式 在强制模式中显示 app 消耗自定义次数, 并且关闭强制模式时可以开启时延,避免冲动娱乐 下面是带开发的 app 功能, 等什么时候有空的时候再做一下吧\n选中 app 指定时间才显示出来,其余时间一直隐藏 ","date":"2026-01-28T12:00:00+08:00","permalink":"https://wake0p.github.io/p/xphone-%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/","title":"Xphone 开发心得"},{"content":" 参考文章\n初识JNI/NDK NDK（Native Development Kit）是一个允许开发者使用C和C++编写Android应用程序的工具集。它提供了一系列的工具和库，可以帮助开发者将高性能的原生代码集成到Android应用中\nNDK的主要目标是提供一种方式，让开发者能够在需要更高性能或更底层控制的情况下使用C和C++编写部分应用程序，而不仅仅依赖于Java。\nJNI（Java Native Interface）是一种编程框架，用于在Java代码和原生代码（如C和C++）之间进行交互。通过JNI，开发者可以在Java代码中调用原生代码的函数，并且可以将Java对象传递给原生代码进行处理。\nJNI 开发大致框架 android studio创建 Native项目 创建好了Natvie项目后，需要点开Tools→SDK Manager下载 NDK和CMake\n静态注册Native方法 Java层注册/调用 在任意类的中，要想调用JNI .so层的native方法需要存在如下定义\n1 2 3 4 //导入.so中的代码 static { System.loadLibrary(\u0026#34;learnjni\u0026#34;); } 并且存在相应的Native函数声明\n1 2 3 public native String stringFromJNI(); public native String stringFromJAVA(); public native String stringFromC(); 然后就能在该class中调用这些Native函数方法\nc/c++层定义 上面导入的libc库文件learnjni，是在cpp/CMakeLists中定义的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # For more information about using CMake with Android Studio, read the # documentation: https://d.android.com/studio/projects/add-native-code.html. # For more examples on how to use CMake, see https://github.com/android/ndk-samples. # Sets the minimum CMake version required for this project. cmake_minimum_required(VERSION 3.22.1) # Declares the project name. The project name can be accessed via ${ PROJECT_NAME}, # Since this is the top level CMakeLists.txt, the project name is also accessible # with ${CMAKE_PROJECT_NAME} (both CMake variables are in-sync within the top level # build script scope). project(\u0026#34;learnjni\u0026#34;) # Creates and names a library, sets it as either STATIC # or SHARED, and provides the relative paths to its source code. # You can define multiple libraries, and CMake builds them for you. # Gradle automatically packages shared libraries with your APK. # # In this top level CMakeLists.txt, ${CMAKE_PROJECT_NAME} is used to define # the target library name; in the sub-module\u0026#39;s CMakeLists.txt, ${PROJECT_NAME} # is preferred for the same purpose. # # In order to load a library into your app from Java/Kotlin, you must call # System.loadLibrary() and pass the name of the library defined here; # for GameActivity/NativeActivity derived applications, the same library name must be # used in the AndroidManifest.xml file. add_library(${CMAKE_PROJECT_NAME} SHARED # List C/C++ source files with relative paths to this CMakeLists.txt. native-lib.cpp) # Specifies libraries CMake should link to your target library. You # can link libraries from various origins, such as libraries defined in this # build script, prebuilt third-party libraries, or Android system libraries. target_link_libraries(${CMAKE_PROJECT_NAME} # List libraries link to the target library android log) 其中的add_library用于添加生产库的源代码文件，比如这里的native-lib.cpp，然后再来看看native-lib.cpp中的c语言如何Java进行交互\n初始化生成的代码如下\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;jni.h\u0026gt; #include \u0026lt;string\u0026gt; extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_learnjni_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */ thiz ) { std::string hello = \u0026#34;Hello from C++\u0026#34;; return env-\u0026gt;NewStringUTF(hello.c_str()); } 首先来看函数函数前一行声明\nextern \u0026ldquo;C\u0026quot;表示下面的函数通过c语言进行编译 JNIEXPORT表示函数是JNI中的导出函数，能过在JAVA代码中调用 JNICALL修饰符告诉编译器函数调用约定为JNI的规范 jstring是该函数的返回类型，J开头代表说JAVA中的类型 再来看看函数命名，其规范如下\n1 Java_包名_类名_方法名 如果其中的名字包含_下划线，通过1_ 来区分。 再来看看函数传递的参数，存在两个参数JNIEnv和jobject，其中JNIEnv定义如下\n1 2 3 4 5 6 7 #if defined(__cplusplus) typedef _JNIEnv JNIEnv; typedef _JavaVM JavaVM; #else typedef const struct JNINativeInterface* JNIEnv; typedef const struct JNIInvokeInterface* JavaVM; #endif 这里区分C和Cpp，先来看Cpp，其JNIEnv就是_JNIEnv的引用，_JNIEnv是一个结构体，包含了很多的函数指针，我们在c语言中处理Java中的类，对象，字段的时候需要用到这些方法。\n由于c语言中环境和JAVA的环境完全不同，JAVA中存在类，类对象这些概念，因此存在如下定义\njclass 表示对Java中的某个类引用 jobject 表示对Java中某个类对象的引用 jstring/jint这里表示Java中的string/int类型 假如要在native层修改Java层类中的一个普通字段String，那么其获取思路如下\n普通字段属于类中的字段，首先需要获取到Java中的类，也就是jclass，存在两个方法\n1 2 jclass GetObjectClass(jobject obj) jclass FindClass(const char* name) 对应的调用例子\n1 2 jclass mainclass = env-\u0026gt;GetObjectClass(thiz); jclass mainclass = env-\u0026gt;FindClass(\u0026#34;com/example/learnjni/MainActivity\u0026#34;); 通过类的对象获取到相应类，这里的thiz就是函数定义的第二个参数jobject(类的对象)， 直接通过包名/类名也可以获取到相应类 获取到Java中的类之后，就能过定位到类中相应字段\n1 jfieldID GetFieldID(jclass clazz, const char* name, const char* sig) 对应调用例子\n1 jfieldID strId = env-\u0026gt;GetFieldID(mainclass,\u0026#34;str\u0026#34;,\u0026#34;Ljava/lang/String;\u0026#34;); clazz表示字段处于到方法 name表示字段名称 sig表示字段的类型，也就是JNI类型 sig中最特殊的就是对象类型，其命名方式为L包名/对象名，这里以Java中的String为例子，JNI类型如下\n1 2 JNI类型 Ljava/lang/String Java类型 java.lang.String 获取到类中的字段后，就能修改其字段的值 1 2 3 4 void SetObjectField(jobject obj, jfieldID fieldID, jobject value) jstring modify = env-\u0026gt;NewStringUTF(\u0026#34;Hellow Java ,这是修改后的普通字段\u0026#34;); env-\u0026gt;SetObjectField(thiz,strId,modify); 要在c语言中修改的Java中的字符串，因此value需要jstring类型，通过NewStringUTF方法进行转换即可。\n以上就是获取java中的类，对象，以及类中的字段，如果要修改的字段为静态的，和普通字段类似\n1 2 3 4 5 6 7 8 9 10 extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_learnjni_MainActivity_staticFromC(JNIEnv * env,jobject thiz){ //modfty static string from Java // jclass mainclass = env-\u0026gt;FindClass(\u0026#34;com/example/learnjni/MainActivity\u0026#34;); jclass mainclass = env-\u0026gt;GetObjectClass(thiz); jfieldID strId = env-\u0026gt;GetStaticFieldID(mainclass,\u0026#34;static_str\u0026#34;,\u0026#34;Ljava/lang/String;\u0026#34;); jstring modify = env-\u0026gt;NewStringUTF(\u0026#34;Hellow Java ,这是修改后的静态字段\u0026#34;); env-\u0026gt;SetStaticObjectField(mainclass,strId,modify); return nullptr; } 唯一的区别在于静态static字段属于整个class类，而普通字段属于类的实例对象，因此在调用\nsetxxxObject的时候，static字段传入的类，普通字段传入的类的对象thiz。\n在来看看c语言的情况\n1 2 typedef const struct JNINativeInterface* JNIEnv; typedef const struct JNIInvokeInterface* JavaVM; 由于c语言没类机制，因此JNIEnv是一个指针，指向JNINativeInterface的结构题,该结构体和cpp中的_JNIEnv长得很像\n其实本质上_JNIEnv就是JNINativeInterface类的封装，你会发现_JNIEnv中的函数，其实最终都调用JNINativeInterface类中的函数(Fuctions→xxx)。\n而传入的参数为JNIEnv * evn，因此evn是一个二级指针，要想获取到JNINativeInterface结构体中的函数需要先解引用得到JNINativeInterface *的指针，c语言调用JNI的方法如下\n1 (*evn)-\u0026gt;function(xxx); 理解了上面类，对象获取的方法，那么再来看看下面的代码就十分容易理解了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_learnjni_MainActivity_stringFromMethod(JNIEnv * env,jobject thiz){ jclass mainclass = env-\u0026gt;GetObjectClass(thiz); jmethodID voidMethod = env-\u0026gt;GetMethodID(mainclass,\u0026#34;str_method\u0026#34;, \u0026#34;()V\u0026#34;); env-\u0026gt;CallVoidMethod(thiz,voidMethod); return nullptr; } extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_learnjni_MainActivity_staticFromMethod(JNIEnv * env,jobject thiz){ jclass mainclass = env-\u0026gt;GetObjectClass(thiz); jmethodID voidMethod = env-\u0026gt;GetStaticMethodID(mainclass,\u0026#34;static_method\u0026#34;, \u0026#34;()V\u0026#34;); env-\u0026gt;CallStaticVoidMethod(mainclass,voidMethod); return nullptr; } 上面代码就是在cpp中调用了Java中的方法，这里需要注意获取方法ID的时候提供sig的目的在于区分重载函数\n动态注册 除了让代码静态注册到.so库文件中，JNI还提供了动态注册native层代码方法，其实现方法就是在加载libc.so到库文件时，自动执行JNI_Onload函数，在该函数中进行代码的动态注册，具体实现思路如下\njava层和静态注册相同，直接声明该方法即可，比如这里的intNum 1 public native int intNum(int num); 再cpp/c层不再更具JNI函数命名规则进行命名，而是直接以原名字编写 1 2 3 jint intNum(JNIEnv* env, jobject thiz,jint num){ return num + 123; } 再定义JNI_OnLoad将intNum函数注册即可(注意JNI_OnLoad中的L是大写) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 extern \u0026#34;C\u0026#34; JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM * vm , void * reserved){ JNIEnv * evn = nullptr; jint result = vm-\u0026gt;GetEnv((void **)\u0026amp;evn,JNI_VERSION_1_6); if(result != JNI_OK){ return -1; } jclass mainclass = evn-\u0026gt;FindClass(\u0026#34;com/example/learnjni/MainActivity\u0026#34;); JNINativeMethod methods[] = { {\u0026#34;intNum\u0026#34;,\u0026#34;(I)I\u0026#34;,(void *)intNum}, }; evn-\u0026gt;RegisterNatives(mainclass,methods,1); return JNI_VERSION_1_6; } 其注册的思路如下\n注册需要用到evn-\u0026gt;RegisterNatives,因此先通过vm→GetEnv获取JNIEnv,并判断是否获取成功\nRegisterNatives函数需要包含JNINativeMethod结构题的数组参数，其定义如下\n1 2 3 4 5 typedef struct { const char* name; //函数名称 const char* signature; // 函数签名 其参数类型和返回值类型 void* fnPtr; //函数指针，指向第一步定义的本地函数 } JNINativeMethod; 因此先注册methods数组当中RegisterNatives\n然后获取到注册的Java类jclass，最后调用evn-\u0026gt;RegisterNatives注册methods数组中的函数，第三个参数1代表methods数组中方法个数。\n最后JNI_Onload函数需要返回本次注册函数的JNI版本\n这里再记录一下安卓apk加载动态库.so文件的执行函数过程如下\n1 .init -\u0026gt; .init_array -\u0026gt; JNI_Onload code 最后附上代码\nnative-lib.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;jni.h\u0026gt; #include \u0026lt;string\u0026gt; extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_learnjni_MainActivity_stringFromJNI( JNIEnv* env, jobject /* this */ ) { std::string hello = \u0026#34;Hello from C++\u0026#34;; return env-\u0026gt;NewStringUTF(hello.c_str()); } extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_learnjni_MainActivity_stringFromJAVA(JNIEnv * env,jobject thiz){ //modfty string from Java jclass mainclass = env-\u0026gt;FindClass(\u0026#34;com/example/learnjni/MainActivity\u0026#34;); jfieldID strId = env-\u0026gt;GetFieldID(mainclass,\u0026#34;str\u0026#34;,\u0026#34;Ljava/lang/String;\u0026#34;); jstring modify = env-\u0026gt;NewStringUTF(\u0026#34;Hellow Java ,这是修改后的普通字段\u0026#34;); env-\u0026gt;SetObjectField(thiz,strId,modify); return nullptr; } extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_learnjni_MainActivity_staticFromC(JNIEnv * env,jobject thiz){ //modfty static string from Java // jclass mainclass = env-\u0026gt;FindClass(\u0026#34;com/example/learnjni/MainActivity\u0026#34;); jclass mainclass = env-\u0026gt;GetObjectClass(thiz); jfieldID strId = env-\u0026gt;GetStaticFieldID(mainclass,\u0026#34;static_str\u0026#34;,\u0026#34;Ljava/lang/String;\u0026#34;); jstring modify = env-\u0026gt;NewStringUTF(\u0026#34;Hellow Java ,这是修改后的静态字段\u0026#34;); env-\u0026gt;SetStaticObjectField(mainclass,strId,modify); return nullptr; } extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_learnjni_MainActivity_stringFromMethod(JNIEnv * env,jobject thiz){ jclass mainclass = env-\u0026gt;GetObjectClass(thiz); jmethodID voidMethod = env-\u0026gt;GetMethodID(mainclass,\u0026#34;str_method\u0026#34;, \u0026#34;()V\u0026#34;); env-\u0026gt;CallVoidMethod(thiz,voidMethod); return nullptr; } extern \u0026#34;C\u0026#34; JNIEXPORT jstring JNICALL Java_com_example_learnjni_MainActivity_staticFromMethod(JNIEnv * env,jobject thiz){ jclass mainclass = env-\u0026gt;GetObjectClass(thiz); jmethodID voidMethod = env-\u0026gt;GetStaticMethodID(mainclass,\u0026#34;static_method\u0026#34;, \u0026#34;()V\u0026#34;); env-\u0026gt;CallStaticVoidMethod(mainclass,voidMethod); return nullptr; } jint intNum(JNIEnv* env, jobject thiz, jint num) { return num + 123; } extern \u0026#34;C\u0026#34; JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM * vm , void * reserved){ JNIEnv * evn = nullptr; jint result = vm-\u0026gt;GetEnv((void **)\u0026amp;evn,JNI_VERSION_1_4); if(result != JNI_OK){ return -1; } jclass mainclass = evn-\u0026gt;FindClass(\u0026#34;com/example/learnjni/MainActivity\u0026#34;); JNINativeMethod methods[] = { {\u0026#34;intNum\u0026#34;,\u0026#34;(I)I\u0026#34;,(void *)intNum}, }; evn-\u0026gt;RegisterNatives(mainclass,methods,1); return JNI_VERSION_1_4; } MainAvtivity\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package com.example.learnjni; import androidx.appcompat.app.AppCompatActivity; import android.os.Bundle; import android.util.Log; import android.widget.TextView; import android.widget.Toast; import com.example.learnjni.databinding.ActivityMainBinding; public class MainActivity extends AppCompatActivity { public native int intNum(int num); public String str = \u0026#34;Helloc Java 我是普通字段\u0026#34;; public static AppCompatActivity your_this; public static String static_str = \u0026#34;Helloc Java 我是静态字段\u0026#34;; // Used to load the \u0026#39;learnjni\u0026#39; library on application startup. static { System.loadLibrary(\u0026#34;learnjni\u0026#34;); } public void str_method() { Toast.makeText(this, \u0026#34;普通方法\u0026#34;, Toast.LENGTH_LONG).show(); } public static void static_method() { Toast.makeText(your_this, \u0026#34;静态方法\u0026#34;, Toast.LENGTH_LONG).show(); } private ActivityMainBinding binding; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); your_this = this; binding = ActivityMainBinding.inflate(getLayoutInflater()); setContentView(binding.getRoot()); // Example of a call to a native method TextView tv = binding.sampleText; tv.setText(stringFromJNI()); String ret = String.valueOf(intNum(123)); tv.setText(ret); } /** * A native method that is implemented by the \u0026#39;learnjni\u0026#39; native library, * which is packaged with this application. */ public native String stringFromJNI(); public native String stringFromJAVA(); public native String staticFromC(); public native String stringFromMethod(); public native String staticFromMethod(); } ","date":"2025-02-21T00:00:00Z","permalink":"https://wake0p.github.io/p/android-jni%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80/","title":"android JNI开发基础"},{"content":"categories 该目录下记录的是相关目录，比如这里的categories/Text 就对应下面这里\n然后该目录下的_index.md，用于渲染这个\n1 2 3 4 5 6 7 8 --- title: \u0026#34;Test\u0026#34; description: \u0026#34;123\u0026#34; image: \u0026#34;hutomo-abrianto-l2jk-uxb1BY-unsplash.jpg\u0026#34; style: background: \u0026#34;#f08080\u0026#34; color: \u0026#34;#fff\u0026#34; --- 其中title和decription就是在这个页面的顶部，存在描述，标题，和图像\n然后下面是对应带有该标签的文章，而style代表这个标签的样式，这里就是背景浅红色，字体白色\npage目录 page目录下存在其他文件夹，分别就对应左侧的选项\n这里侧边选项是通过menu main 来定义的\n每一个目录下存在一个index.md/index.zh-cn.md ，其中渲染部分如下\n1 2 3 4 5 6 7 8 9 10 11 --- title: \u0026#34;Archives\u0026#34; date: 2019-05-28 layout: \u0026#34;archives\u0026#34; slug: \u0026#34;archives\u0026#34; menu: main: weight: -70 params: icon: archives --- 其中titile表示侧边拦的名称， data好像没啥用处， layout表示布局使用layouts文件下的archives.html布局 slug表示当前页面的网站索引，比如这里的/wake0p.github.io/archives menu用于表示当前index.md是为左侧边栏服务的 1 2 3 4 5 menu: main: weight: -70 params: icon: archives weight: -70：weight 用来控制菜单项的排序。数字越小，菜单项会显示得越靠前，越大则越靠后。-70 表示该页面在菜单中的位置比较靠前（在相同 weight 的情况下）。 params:：这是菜单项的附加参数。你可以在这里指定图标、样式、链接等额外的设置。 icon: archives：表示在这个菜单项中会使用一个名为 archives 的图标。具体来说，网站的图标可能是一个与归档相关的图标（如文件夹或文件堆叠的图标），并且可以通过CSS或其他方式进行自定义显示。 当然还存在其他属性，比如在Links文件下，就Links属性，用于表示参考文章，使用方法如下\n1 2 3 4 5 6 7 8 9 links: - title: GitHub description: My GitHub website: https://github.com/wake0p image: https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png - title: TypeScript description: TypeScript is a typed superset of JavaScript that compiles to plain JavaScript. website: https://www.typescriptlang.org image: ts-logo-128.jpg 其中image即能够用网上的，也能够使用本地，最后的效果就是在底部存在这样的参考文章\npost目录 这个目录用于存放真正需要发布文章，一般分为两种情况，\n要么是直接/post/xxx.md 这种md中不引用图片， 要么就是/post/xxx/index.md将资源单独放在一个文件夹，文件夹包含所需要的所有资源 比较推荐第二种做法\n然后就是post中文章有的相关属性\n1 2 3 4 5 6 7 8 9 10 --- title: Chinese Test description: 这是一个副标题 date: 2020-09-09 slug: test-Chinese image: helena-hertz-wWZzXlDpMog-unsplash.jpg categories: - Test --- date表示发布时间 image表示文章的背景图片 categories表示当前文章属于哪一个目录，可以说目录中有的，也可也是目录中没有的 最终的情况就像下面这样\n图片排版方法 将两个图片放在同一排，就像下面这样\n1 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) 最终的效果\n当然也能够4张图片全部排在一起\n","date":"2025-02-12T00:00:00Z","permalink":"https://wake0p.github.io/p/content%E7%9B%AE%E5%BD%95%E4%BD%BF%E7%94%A8/","title":"content目录使用"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://wake0p.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://wake0p.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode Twitter Simple Shortcode “In addition to being more logical, asymmetry has the advantage that its complete appearance is far more optically effective than symmetry.”\n— Jan Tschichold pic.twitter.com/gcv7SrhvJb\n\u0026mdash; Design Reviewed | Graphic Design History (@DesignReviewed) January 17, 2019 Vimeo Simple Shortcode bilibilibi Shortcode Gist Shortcode Gitlab Snippets Shortcode Quote Shortcode Stack adds a quote shortcode. For example:\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Anonymous book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Some book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Somebody","date":"2019-03-10T00:00:00Z","permalink":"https://wake0p.github.io/p/rich-content/","title":"Rich Content"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://wake0p.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://wake0p.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://wake0p.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://wake0p.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://wake0p.github.io/p/emoji-support/","title":"Emoji Support"}]